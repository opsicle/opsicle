package approver

import (
	"context"
	"encoding/json"
	"fmt"
	"opsicle/internal/common"
	"opsicle/internal/config"
	"opsicle/internal/integrations/telegram"
	"strings"

	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
	"github.com/sirupsen/logrus"
)

var TelegramApprover *telegramApprover

type telegramApprover struct {
	Client      *telegram.Bot
	ChatMap     map[string]int64
	ServiceLogs chan<- common.ServiceLog
}

func (t *telegramApprover) Start(done chan common.Done) {
	go func() {
		<-done
		t.Client.Done <- common.Done{}
	}()
	logrus.Infof("started telegram client")
	t.Client.Start()
}

type SendApprovalOpts struct {
	Chat string
}

func (t *telegramApprover) SendApproval(req ApprovalRequest, opts SendApprovalOpts) error {
	chatId, ok := t.ChatMap[opts.Chat]
	if !ok {
		return fmt.Errorf("failed to find chat[%s]", opts.Chat)
	}

	text := fmt.Sprintf("%s is requesting approval from %s to run automation: %s", req.Requester, req.Approver, req.AutomationName)

	approveBtn := &models.InlineKeyboardButton{
		Text:         "Approve",
		CallbackData: fmt.Sprintf("approve:%s", req.Id),
	}
	rejectBtn := &models.InlineKeyboardButton{
		Text:         "Reject",
		CallbackData: fmt.Sprintf("reject:%s", req.Id),
	}

	markup := &models.InlineKeyboardMarkup{
		InlineKeyboard: [][]models.InlineKeyboardButton{{*approveBtn, *rejectBtn}},
	}

	ctx := context.Background()
	fmt.Println(t.Client.Raw)
	fmt.Printf("sending message to chat[%v]\n", chatId)
	fmt.Printf("sending text['%s']\n", text)
	_, err := t.Client.Client.SendMessage(ctx, &bot.SendMessageParams{
		ChatID:      chatId,
		Text:        text,
		ReplyMarkup: markup,
	})
	return err
}

type InitTelegramApproverOpts struct {
	// BotToken is a token generated by the @BotFather on
	// Telegram - get yours at https://t.me/BotFather
	BotToken string `json:"botToken" yaml:"botToken"`

	// ChatMap maps a logical chat name to it's ID in Telegram
	ChatMap map[string]int64 `json:"chatMap" yaml:"chatMap"`

	// ServiceLogs is the channel to send logs to for logging via
	// the centralised logger
	ServiceLogs chan<- common.ServiceLog
}

func InitTelegramApprover(opts InitTelegramApproverOpts) error {
	var err error
	telegramBot, err := telegram.New(telegram.NewOpts{
		BotToken:       opts.BotToken,
		DefaultHandler: getHandler(opts.ServiceLogs),
		ServiceLogs:    opts.ServiceLogs,
	})
	if err != nil {
		return fmt.Errorf("failed to create telegram bot: %s", err)
	}
	TelegramApprover = &telegramApprover{
		Client:      telegramBot,
		ChatMap:     opts.ChatMap,
		ServiceLogs: opts.ServiceLogs,
	}
	return nil
}

func getHandler(serviceLogs chan<- common.ServiceLog) func(context.Context, *telegram.Bot, telegram.BotUpdate) {
	return func(ctx context.Context, b *telegram.Bot, update telegram.BotUpdate) {
		serviceLogs <- common.ServiceLog{config.LogLevelInfo, fmt.Sprintf("chat[%v] << %s", update.ChatId, update.Message)}
		data := update.CallbackData
		parts := strings.SplitN(data, ":", 2)
		if len(parts) != 2 {
			serviceLogs <- common.ServiceLog{config.LogLevelError, fmt.Sprintf("invalid callback data: %s", data)}
			return
		}

		action := parts[0]
		requestId := parts[1]

		val, err := RedisCache.Client.Get(requestId).Result()
		if err != nil {
			serviceLogs <- common.ServiceLog{config.LogLevelError, fmt.Sprintf("failed to fetch request from Redis: %v", err)}
			return
		}

		var req ApprovalRequest
		if err := json.Unmarshal([]byte(val), &req); err != nil {
			serviceLogs <- common.ServiceLog{config.LogLevelError, fmt.Sprintf("failed to unmarshal request: %v", err)}
			return
		}

		response := fmt.Sprintf("%s has %sd the request to run automation: %s", req.Approver, action, req.AutomationName)

		if err := b.SendMessage(update.ChatId, response); err != nil {
			serviceLogs <- common.ServiceLog{config.LogLevelError, fmt.Sprintf("failed to send confirmation message: %v", err)}
		}
	}
}
