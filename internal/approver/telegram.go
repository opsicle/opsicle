package approver

import (
	"context"
	"fmt"
	"opsicle/internal/common"
	"opsicle/internal/integrations/telegram"
	"strconv"
	"time"

	"github.com/go-telegram/bot"
	"github.com/sirupsen/logrus"
)

type telegramNotifier struct {
	Client      *telegram.Bot
	Done        chan common.Done
	ServiceLogs chan<- common.ServiceLog
}

func (t *telegramNotifier) SendApprovalRequest(req *ApprovalRequest) (string, notificationMessages, error) {
	text := getTelegramApprovalRequestMessage(*req)

	requestUuid := req.Spec.GetUuid()
	requestId := req.Spec.Id
	approveButtonCallbackData := createTelegramApprovalCallbackData(ActionApprove, requestUuid)
	t.ServiceLogs <- common.ServiceLogf(common.LogLevelTrace, "telegram approve button callback data (length: %v): %s", len(approveButtonCallbackData), approveButtonCallbackData)
	rejectButtonCallbackData := createTelegramApprovalCallbackData(ActionReject, requestUuid)
	t.ServiceLogs <- common.ServiceLogf(common.LogLevelTrace, "telegram reject button callback data (length: %v): %s", len(rejectButtonCallbackData), rejectButtonCallbackData)
	customKeyboard := getTelegramApprovalKeyboard(
		approveButtonCallbackData,
		rejectButtonCallbackData,
	)

	ctx := context.Background()
	t.ServiceLogs <- common.ServiceLogf(common.LogLevelInfo, "sending via telegram...")
	notifications := notificationMessages{}

	hasChatIdBeenMessaged := map[int64]bool{}
	for _, target := range req.Spec.Telegram {
		t.ServiceLogs <- common.ServiceLogf(common.LogLevelDebug, "sending message to chat[%v]: %s", target.ChatId, text)
		for _, chatId := range target.ChatIds {
			if messaged, ok := hasChatIdBeenMessaged[chatId]; ok || messaged {
				continue
			}
			notification := notificationMessage{
				Id:       requestUuid,
				TargetId: strconv.FormatInt(chatId, 10),
				Platform: NotifierPlatformTelegram,
			}
			msg, err := t.Client.Client.SendMessage(ctx, &bot.SendMessageParams{
				ChatID:      chatId,
				Text:        text,
				ParseMode:   "MarkdownV2",
				ReplyMarkup: customKeyboard,
			})
			if err != nil {
				t.ServiceLogs <- common.ServiceLogf(common.LogLevelError, "req[%s:%s] failed to send message to chat[%v]: %s", requestId, requestUuid, chatId, err)
				notification.Error = err
			} else {
				notification.IsSuccess = true
				notification.MessageId = strconv.FormatInt(int64(msg.ID), 10)
				notification.SentAt = time.Now()
			}
			hasChatIdBeenMessaged[chatId] = true
			notifications = append(notifications, notification)
		}
	}

	return requestUuid, notifications, nil
}

func (t *telegramNotifier) StartListening() {
	t.Done = make(chan common.Done)
	go func() {
		<-t.Done
		t.Client.Done <- common.Done{}
	}()
	logrus.Infof("started telegram client")
	t.Client.Start()
}

func (t *telegramNotifier) Stop() {
	t.Done <- common.Done{}
}

type InitTelegramNotifierOpts struct {
	// BotToken is a token generated by the @BotFather on
	// Telegram - get yours at https://t.me/BotFather
	BotToken string `json:"botToken" yaml:"botToken"`

	// DefaultHandler enables overriding the default handler
	DefaultHandler telegram.Handler

	// ServiceLogs is the channel to send logs to for logging via
	// the centralised logger
	ServiceLogs chan<- common.ServiceLog
}

func InitTelegramNotifier(opts InitTelegramNotifierOpts) error {
	var err error
	var defaultHandler telegram.Handler
	if opts.DefaultHandler == nil {
		defaultHandler = getDefaultHandler(opts.ServiceLogs)
	} else {
		defaultHandler = opts.DefaultHandler
	}
	telegramBot, err := telegram.New(telegram.NewOpts{
		BotToken:       opts.BotToken,
		DefaultHandler: defaultHandler,
		ServiceLogs:    opts.ServiceLogs,
	})
	if err != nil {
		return fmt.Errorf("failed to create telegram bot: %s", err)
	}
	Notifiers = append(
		Notifiers,
		&telegramNotifier{
			Client:      telegramBot,
			ServiceLogs: opts.ServiceLogs,
		},
	)
	return nil
}
