package approver

import (
	"context"
	"encoding/json"
	"fmt"
	"opsicle/internal/common"
	"opsicle/internal/integrations/telegram"
	"strconv"
	"strings"
	"time"

	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
	"github.com/sirupsen/logrus"
)

type telegramApprover struct {
	Client      *telegram.Bot
	ChatMap     map[string]int64
	Done        chan common.Done
	ServiceLogs chan<- common.ServiceLog
}

func (t *telegramApprover) StartListening() {
	t.Done = make(chan common.Done)
	go func() {
		<-t.Done
		t.Client.Done <- common.Done{}
	}()
	logrus.Infof("started telegram client")
	t.Client.Start()
}

func (t *telegramApprover) Stop() {
	t.Done <- common.Done{}
}

func (t *telegramApprover) SendApproval(req ApprovalRequest) (string, []notificationMessage, error) {
	text := fmt.Sprintf(
		"âš ï¸ Approval request\nID: `%s`\nMessage: `%s`\nRequester: %s \\(`%s`\\)",
		bot.EscapeMarkdown(req.Spec.Id),
		bot.EscapeMarkdown(req.Spec.Message),
		bot.EscapeMarkdown(req.Spec.RequesterName),
		bot.EscapeMarkdown(req.Spec.RequesterId),
	)

	notificationId := req.Spec.GetUuid()
	customKeyboard := createTelegramApprovalKeyboard(
		createTelegramApprovalCallbackData(ActionApprove, notificationId, req.Spec.Id),
		createTelegramApprovalCallbackData(ActionReject, notificationId, req.Spec.Id),
	)

	ctx := context.Background()
	t.ServiceLogs <- common.ServiceLogf(common.LogLevelInfo, "sending via telegram...")
	notifications := notificationMessages{}

	// only target telegram targets
	for _, target := range req.Spec.Telegram {
		t.ServiceLogs <- common.ServiceLogf(common.LogLevelDebug, "sending message to chat[%v]: %s", target.ChatId, text)
		notification := notificationMessage{
			Id:       notificationId,
			TargetId: strconv.FormatInt(target.ChatId, 10),
			Platform: NotifierPlatformTelegram,
		}
		msg, err := t.Client.Client.SendMessage(ctx, &bot.SendMessageParams{
			ChatID:      target.ChatId,
			Text:        text,
			ParseMode:   "MarkdownV2",
			ReplyMarkup: customKeyboard,
		})
		if err != nil {
			t.ServiceLogs <- common.ServiceLogf(common.LogLevelError, "req[%v] failed to send message to chat[%v]: %s", req.Spec.Id, target.ChatId, err)
			notification.Error = err
		} else {
			notification.IsSuccess = true
			notification.MessageId = strconv.FormatInt(int64(msg.ID), 10)
			notification.SentAt = time.Now()
		}
		notifications = append(notifications, notification)
	}

	return notificationId, notifications, nil
}

type InitTelegramNotifierOpts struct {
	// BotToken is a token generated by the @BotFather on
	// Telegram - get yours at https://t.me/BotFather
	BotToken string `json:"botToken" yaml:"botToken"`

	// ChatMap maps a logical chat name to it's ID in Telegram
	ChatMap map[string]int64 `json:"chatMap" yaml:"chatMap"`

	// DefaultHandler enables overriding the default handler
	DefaultHandler telegram.Handler

	// ServiceLogs is the channel to send logs to for logging via
	// the centralised logger
	ServiceLogs chan<- common.ServiceLog
}

func InitTelegramNotifier(opts InitTelegramNotifierOpts) error {
	var err error
	var defaultHandler telegram.Handler
	if opts.DefaultHandler == nil {
		defaultHandler = getHandler(opts.ServiceLogs)
	} else {
		defaultHandler = opts.DefaultHandler
	}
	telegramBot, err := telegram.New(telegram.NewOpts{
		BotToken:       opts.BotToken,
		DefaultHandler: defaultHandler,
		ServiceLogs:    opts.ServiceLogs,
	})
	if err != nil {
		return fmt.Errorf("failed to create telegram bot: %s", err)
	}
	Notifier = &telegramApprover{
		Client:      telegramBot,
		ChatMap:     opts.ChatMap,
		ServiceLogs: opts.ServiceLogs,
	}
	return nil
}

func getHandler(
	serviceLogs chan<- common.ServiceLog,
) func(context.Context, *telegram.Bot, *telegram.Update) {
	return func(ctx context.Context, b *telegram.Bot, update *telegram.Update) {
		serviceLogs <- common.ServiceLogf(common.LogLevelInfo, "chat[%v] << %s", update.ChatId, update.Message)
		if update.CallbackData == "" {
			o, _ := json.MarshalIndent(update, "", "  ")
			serviceLogs <- common.ServiceLogf(common.LogLevelDebug, "received non-callback data:\n%s", string(o))
			if err := b.ReplyMessage(update.ChatId, update.MessageId, "ðŸ™‡ðŸ¼ Apologies, that's beyond my paygrade"); err != nil {
				serviceLogs <- common.ServiceLogf(common.LogLevelError, "failed to send error response to user: %s", err)
			}
			return
		}
		action, notificationId, requestId, err := ParseTelegramApprovalCallbackData(update.CallbackData)
		if err != nil {
			serviceLogs <- common.ServiceLogf(common.LogLevelError, "failed to parse callback: %s", err)
			if err := b.ReplyMessage(update.ChatId, update.MessageId, "ðŸ™‡ðŸ¼ Apologies, something went wrong internally"); err != nil {
				serviceLogs <- common.ServiceLogf(common.LogLevelError, "failed to send error response to user: %s", err)
			}
			return
		}

		val, err := Cache.Get(CreateCacheKey(notificationId, requestId))
		if err != nil {
			serviceLogs <- common.ServiceLogf(common.LogLevelError, "failed to fetch request from cache: %v", err)
			return
		}
		var response string
		if val == "" {
			response = "this request was not found"
		} else if val == "approved" {
			response = fmt.Sprintf("this request has already been approved")
		} else if val == "rejected" {
			response = fmt.Sprintf("this request has already been rejected")
		} else if action == ActionApprove {
			if err := Cache.Set(approvalRequestCachePrefix+requestId, "approved", 0); err != nil {
				serviceLogs <- common.ServiceLogf(common.LogLevelError, "failed to set cache value: %v", err)
			}
			response = "this request has been approved"
		} else if action == ActionReject {
			if err := Cache.Set(approvalRequestCachePrefix+requestId, "rejected", 0); err != nil {
				serviceLogs <- common.ServiceLogf(common.LogLevelError, "failed to set cache value: %v", err)
			}
			response = "this request has been rejected"
		}

		if err := b.SendMessage(update.ChatId, response); err != nil {
			serviceLogs <- common.ServiceLogf(common.LogLevelError, "failed to send confirmation message: %v", err)
		}
	}
}

func createTelegramApprovalKeyboard(approvalData, rejectionData string) models.ReplyMarkup {
	return &models.InlineKeyboardMarkup{
		InlineKeyboard: [][]models.InlineKeyboardButton{{
			models.InlineKeyboardButton{
				Text:         "Approve",
				CallbackData: approvalData,
			},
			models.InlineKeyboardButton{
				Text:         "Reject",
				CallbackData: rejectionData,
			},
		}},
	}
}

func createTelegramApprovalCallbackData(action Action, notificationId string, requestId string) (callbackData string) {
	callbackData = fmt.Sprintf("%s:%s:%s", action, notificationId, requestId)
	return
}

func ParseTelegramApprovalCallbackData(callbackData string) (action Action, notificationId string, requestId string, err error) {
	splitCallbackData := strings.Split(callbackData, ":")
	if len(splitCallbackData) != 3 {
		return "", "", "", fmt.Errorf("failed to parse callback data: expected [{action}:{notificationId}:{requestId}] but received callbackData[%s]", callbackData)
	}
	action = Action(splitCallbackData[0])
	notificationId = splitCallbackData[1]
	requestId = splitCallbackData[2]
	err = nil
	return
}
