package approver

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"opsicle/internal/common"
	"strconv"
	"strings"

	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
	"github.com/sirupsen/logrus"
)

var TelegramApprover *telegramApprover

type telegramApprover struct {
	Client  *bot.Bot
	ChatMap map[string]string
}

func (t *telegramApprover) Start(done chan common.Done) {
	ctx := context.Background()
	go func() {
		<-done
		if _, err := t.Client.Close(ctx); err != nil {
			logrus.Errorf("failed to close telegram bot: %s", err)
		}
	}()
	logrus.Infof("started telegram client")
	t.Client.Start(ctx)
}

type SendApprovalOpts struct {
	Chat string
}

func (t *telegramApprover) SendApproval(req ApprovalRequest, opts SendApprovalOpts) error {
	chatIdValue, ok := t.ChatMap[opts.Chat]
	if !ok {
		return fmt.Errorf("failed to find chat[%s]", opts.Chat)
	}
	chatId, err := strconv.ParseInt(chatIdValue, 10, 64)
	if err != nil {
		return err
	}

	text := fmt.Sprintf("%s is requesting approval from %s to run automation: %s", req.Requester, req.Approver, req.AutomationName)

	approveBtn := &models.InlineKeyboardButton{
		Text:         "Approve",
		CallbackData: fmt.Sprintf("approve:%s", req.Id),
	}
	rejectBtn := &models.InlineKeyboardButton{
		Text:         "Reject",
		CallbackData: fmt.Sprintf("reject:%s", req.Id),
	}

	markup := &models.InlineKeyboardMarkup{
		InlineKeyboard: [][]models.InlineKeyboardButton{{*approveBtn, *rejectBtn}},
	}

	ctx := context.Background()
	_, err = t.Client.SendMessage(ctx, &bot.SendMessageParams{
		ChatID:      chatId,
		Text:        text,
		ReplyMarkup: markup,
	})
	return err
}

type InitTelegramApproverOpts struct {
	// BotToken is a token generated by the @BotFather on
	// Telegram - get yours at https://t.me/BotFather
	BotToken string `json:"botToken" yaml:"botToken"`

	// ChatMap maps a logical chat name to it's ID in Telegram
	ChatMap map[string]string `json:"chatMap" yaml:"chatMap"`
}

func InitTelegramApprover(opts InitTelegramApproverOpts) error {
	client, err := bot.New(opts.BotToken, bot.WithDefaultHandler(handleTelegramCallback))
	if err != nil {
		return fmt.Errorf("failed to initialize Telegram bot: %v", err)
	}
	TelegramApprover = &telegramApprover{
		Client:  client,
		ChatMap: opts.ChatMap,
	}
	return nil
}

func handleTelegramCallback(ctx context.Context, b *bot.Bot, update *models.Update) {
	logrus.Infof("%v", update.Message.Chat.ID)
	if update.CallbackQuery == nil {
		return
	}

	data := update.CallbackQuery.Data
	parts := strings.SplitN(data, ":", 2)
	if len(parts) != 2 {
		log.Printf("invalid callback data: %s", data)
		return
	}

	action := parts[0]
	requestId := parts[1]

	val, err := RedisCache.Client.Get(requestId).Result()
	if err != nil {
		log.Printf("failed to fetch request from Redis: %v", err)
		return
	}

	var req ApprovalRequest
	if err := json.Unmarshal([]byte(val), &req); err != nil {
		log.Printf("failed to unmarshal request: %v", err)
		return
	}

	response := fmt.Sprintf("%s has %sd the request to run automation: %s", req.Approver, action, req.AutomationName)

	_, err = b.SendMessage(ctx, &bot.SendMessageParams{
		ChatID: update.CallbackQuery.ChatInstance,
		Text:   response,
	})
	if err != nil {
		log.Printf("failed to send confirmation message: %v", err)
	}
}
