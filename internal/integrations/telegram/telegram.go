package telegram

import (
	"context"
	"fmt"
	"opsicle/internal/common"
	"opsicle/internal/config"
	"strconv"
	"time"

	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
)

// BotUpdate is a wrapper around the third party implementation's update model
type BotUpdate struct {
	ChatId       int64
	Message      string
	CallbackData string
	CallbackId   string
	Raw          *models.Update
}

// BotHandler is a wrapper around the third party implementation's handler function
type BotHandler func(context context.Context, bot *Bot, update BotUpdate)

// Bot represents a Telegram bot instance
type Bot struct {
	// Client is an instance of the third-party library we use for
	// interacting with Telegram
	Client *bot.Bot

	// Done is a channel that upon receiving a message, terminates
	// the bot gracefully
	Done chan common.Done

	// ServiceLogs is the channel to send logs to for logging via
	// the centralised logger
	ServiceLogs chan<- common.ServiceLog

	Raw *bot.Bot
}

func (b *Bot) SendMessage(chatId int64, message string) error {
	ctx := context.Background()
	b.ServiceLogs <- common.ServiceLog{
		config.LogLevelDebug,
		fmt.Sprintf("chat[%v] >> '%s'", chatId, message),
	}
	if _, err := b.Client.SendMessage(ctx, &bot.SendMessageParams{
		ChatID:    chatId,
		Text:      message,
		ParseMode: "MarkdownV2",
	}); err != nil {
		return fmt.Errorf("failed to send message: %s", err)
	}
	return nil
}

func (b *Bot) Start() {
	go func() {
		<-b.Done
		ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
		defer cancel()
		if _, err := b.Client.Close(ctx); err != nil {
			b.ServiceLogs <- common.ServiceLog{config.LogLevelError, fmt.Sprintf("failed to close bot: %s", err)}
		}
	}()
	b.ServiceLogs <- common.ServiceLog{config.LogLevelInfo, fmt.Sprintf("starting a telegram bot...")}
	b.Client.Start(context.Background())
}

type NewOpts struct {
	// BotToken is a token generated by the @BotFather on
	// Telegram - get yours at https://t.me/BotFather
	BotToken string `json:"botToken"`

	// DefaultHandler is the default handler for the bot
	DefaultHandler BotHandler

	// Done is a channel that upon receiving a message, terminates
	// the bot gracefully
	Done chan common.Done

	// ServiceLogs is the channel to send logs to for logging via
	// the centralised logger
	ServiceLogs chan<- common.ServiceLog
}

// New initialises a Telegram bot and returns a Bot
func New(opts NewOpts) (*Bot, error) {
	botInstance := &Bot{
		Done:        opts.Done,
		ServiceLogs: opts.ServiceLogs,
	}
	client, err := bot.New(opts.BotToken, bot.WithDefaultHandler(
		func(ctx context.Context, bot *bot.Bot, update *models.Update) {
			var chatId int64
			var message string
			var callbackData string
			var callbackId string
			switch true {
			case update.Message != nil:
				opts.ServiceLogs <- common.ServiceLog{
					config.LogLevelDebug,
					"received update of type[message]",
				}
				chatId = update.Message.From.ID
				message = update.Message.Text
			case update.CallbackQuery != nil:
				opts.ServiceLogs <- common.ServiceLog{
					config.LogLevelDebug,
					"received update of type[callback]",
				}
				var err error
				chatId, err = strconv.ParseInt(update.CallbackQuery.ChatInstance, 0, 10)
				if err != nil {
					opts.ServiceLogs <- common.ServiceLog{config.LogLevelError, fmt.Sprintf("failed to parse chatId[%s]", update.CallbackQuery.ChatInstance)}
				}
				callbackData = update.CallbackQuery.Data
				callbackId = update.CallbackQuery.ID
			}
			opts.ServiceLogs <- common.ServiceLog{
				config.LogLevelDebug,
				fmt.Sprintf("chat[%v] << '%s'", chatId, message),
			}
			botUpdate := BotUpdate{
				ChatId:       chatId,
				Message:      message,
				CallbackData: callbackData,
				CallbackId:   callbackId,
				Raw:          update,
			}
			if update.CallbackQuery != nil {
				botUpdate.CallbackData = update.CallbackQuery.Data
				botUpdate.CallbackId = update.CallbackQuery.ID
			}
			opts.DefaultHandler(ctx, botInstance, botUpdate)
		},
	))
	if err != nil {
		return nil, fmt.Errorf("failed to initialize Telegram bot: %v", err)
	}
	botInstance.Client = client
	return botInstance, nil
}
