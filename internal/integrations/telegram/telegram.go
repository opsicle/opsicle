package telegram

import (
	"context"
	"encoding/json"
	"fmt"
	"opsicle/internal/common"

	"github.com/go-telegram/bot"
	"github.com/go-telegram/bot/models"
)

type NewOpts struct {
	// BotToken is a token generated by the @BotFather on
	// Telegram - get yours at https://t.me/BotFather
	BotToken string `json:"botToken"`

	// DefaultHandler is the default handler for the bot
	DefaultHandler Handler

	// Done is a channel that upon receiving a message, terminates
	// the bot gracefully
	Done chan common.Done

	// ServiceLogs is the channel to send logs to for logging via
	// the centralised logger
	ServiceLogs chan<- common.ServiceLog
}

// New initialises a Telegram bot and returns a Bot
func New(opts NewOpts) (*Bot, error) {
	botInstance := &Bot{
		Done:        opts.Done,
		ServiceLogs: opts.ServiceLogs,
	}
	client, err := bot.New(opts.BotToken, bot.WithDefaultHandler(
		func(ctx context.Context, bot *bot.Bot, update *models.Update) {
			var botUpdate *Update
			switch true {
			case isTextMessage(update):
				botUpdate = serializeTextMessage(update)
				opts.ServiceLogs <- common.ServiceLogf(common.LogLevelDebug, "received update of type[message] in chat[%v]: message['%s']", botUpdate.ChatId, botUpdate.Message)
			case isCallbackQuery(update):
				botUpdate = serializeCallbackQuery(update)
				opts.ServiceLogs <- common.ServiceLogf(common.LogLevelDebug, "received update of type[callback] in chat[%v]: data['%s']", botUpdate.ChatId, botUpdate.CallbackData)
			}
			botUpdate.Raw = update
			o, _ := json.Marshal(botUpdate)
			opts.ServiceLogs <- common.ServiceLogf(common.LogLevelTrace, "update data: '%s'", string(o))
			if update.CallbackQuery != nil {
				botUpdate.CallbackData = update.CallbackQuery.Data
				botUpdate.CallbackId = update.CallbackQuery.ID
			}
			opts.DefaultHandler(ctx, botInstance, botUpdate)
		},
	))
	if err != nil {
		return nil, fmt.Errorf("failed to initialize Telegram bot: %v", err)
	}
	botInstance.Client = client
	return botInstance, nil
}

func isCallbackQuery(update *models.Update) bool {
	return update.CallbackQuery != nil
}

func isTextMessage(update *models.Update) bool {
	return update.Message != nil
}

func serializeCallbackQuery(update *models.Update) *Update {
	chatId := update.CallbackQuery.Message.Message.Chat.ID
	messageId := update.CallbackQuery.Message.Message.ID
	senderId := update.CallbackQuery.From.ID
	senderUsername := update.CallbackQuery.From.Username
	callbackData := update.CallbackQuery.Data
	callbackId := update.CallbackQuery.ID
	return &Update{
		CallbackData:   callbackData,
		CallbackId:     callbackId,
		ChatId:         chatId,
		MessageId:      messageId,
		SenderId:       senderId,
		SenderUsername: senderUsername,
	}
}

func serializeTextMessage(update *models.Update) *Update {
	chatId := update.Message.Chat.ID
	message := update.Message.Text
	messageId := update.Message.ID
	senderId := update.Message.From.ID
	senderUsername := update.Message.From.Username
	isReply := false
	var replyMessageId int
	if update.Message.ReplyToMessage != nil {
		isReply = true
		replyMessageId = update.Message.ReplyToMessage.ID
	}
	return &Update{
		ChatId:         chatId,
		IsReply:        isReply,
		Message:        message,
		MessageId:      messageId,
		ReplyMessageId: replyMessageId,
		SenderId:       senderId,
		SenderUsername: senderUsername,
	}
}
