package cli

import (
	"errors"
	"fmt"
	"opsicle/internal/common"
	"opsicle/pkg/controller"
	"sort"
	"strings"
	"time"

	tea "github.com/charmbracelet/bubbletea"
)

type HandleTemplateSelectionOpts struct {
	// Client should be generated by the cosnuming function
	// and passed into this function for us
	Client *controller.Client

	// UserInput is what a user has input as the template name
	UserInput string

	// ServiceLog is used for streaming logs
	ServiceLog chan<- common.ServiceLog

	// Prompt is an optional string to use that tells the user what
	// they are selecting
	Prompt string

	// StartWithoutFilter indicates whether the selection should be started
	// without filter mode being turned on by default
	StartWithoutFilter bool
}

type Template struct {
	Id                 string
	Name               string
	Version            int64
	CreatedAt          time.Time
	CreatedByEmail     *string
	LastUpdatedAt      *time.Time
	LastUpdatedByEmail *string
}

func HandleTemplateSelection(opts HandleTemplateSelectionOpts) (template *Template, err error) {
	template = &Template{}
	var logs chan<- common.ServiceLog
	if opts.ServiceLog == nil {
		initNoopServiceLog()
		logs = noopServiceLog
		go startNoopServiceLog()
		defer stopNoopServiceLog()
	} else {
		logs = opts.ServiceLog
	}
	logs <- common.ServiceLogf(common.LogLevelDebug, "retrieving available templates to current user")
	templates, err := opts.Client.ListTemplatesV1(controller.ListTemplatesV1Input{
		Limit: 20,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to list templates: %w", err)
	}
	isTemplateNameValid := false
	templateMap := map[string]Template{}
	filterItems := []FilterItem{}
	for _, t := range templates.Data {
		filterItems = append(filterItems, FilterItem{
			Description: fmt.Sprintf("v%v -- %s", t.Version, t.Description),
			Label:       t.Name,
			Value:       strings.Join([]string{t.Name, t.Id}, ":"),
		})
		templateInstance := Template{
			Id:        t.Id,
			Name:      t.Name,
			Version:   int64(t.Version),
			CreatedAt: t.CreatedAt,
		}
		if t.CreatedBy != nil {
			templateInstance.CreatedByEmail = &t.CreatedBy.Email
			templateInstance.CreatedAt = t.CreatedAt
		}
		if t.LastUpdatedBy != nil {
			templateInstance.LastUpdatedByEmail = &t.LastUpdatedBy.Email
			templateInstance.LastUpdatedAt = t.LastUpdatedAt
		}
		templateMap[t.Id] = templateInstance
		if t.Name == opts.UserInput {
			isTemplateNameValid = true
			template = &templateInstance
			break
		}
	}
	if len(templates.Data) == 0 {
		return nil, controller.ErrorNotFound
	}
	if !isTemplateNameValid {
		sort.Slice(filterItems, func(i, j int) bool {
			return filterItems[i].Label < filterItems[j].Label
		})
		promptTitle := "ðŸ’¬ " + opts.Prompt
		if promptTitle == "" {
			promptTitle = "ðŸ’¬ Which template will it be?"
		}
		templateFiltering := CreateFilter(FilterOpts{
			Items:              filterItems,
			Title:              promptTitle,
			StartWithoutFilter: opts.StartWithoutFilter,
		})
		templateFilter := tea.NewProgram(templateFiltering)
		if _, err := templateFilter.Run(); err != nil {
			return nil, fmt.Errorf("failed to get user input: %w", err)
		}
		if templateFiltering.GetExitCode() == PromptCancelled {
			return nil, errors.New("user cancelled")
		}
		selectedTemplate := templateFiltering.GetSelectedItem()
		templateValues := strings.Split(selectedTemplate.Value, ":")
		templateInstance := templateMap[templateValues[1]]
		template = &templateInstance

		err = nil
	}
	return template, err
}
