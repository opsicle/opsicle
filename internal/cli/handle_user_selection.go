package cli

import (
	"errors"
	"fmt"
	"opsicle/internal/common"
	"opsicle/internal/validate"
	"opsicle/pkg/controller"
	"sort"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/google/uuid"
)

type HandleUserSelectionOpts struct {
	// Client should be generated by the cosnuming function
	// and passed into this function for us
	Client *controller.Client

	// UserInput is what a user has input as the org code
	UserInput string

	// Users is a list of selectable users
	Users []HandleUserSelectionOptsUser

	// ServiceLog is used for streaming logs
	ServiceLog chan<- common.ServiceLog
}

type HandleUserSelectionOptsUser struct {
	Id    string
	Email string
}

// HandleUserSelection handles the selection of an organsation
// in the CLI
func HandleUserSelection(opts HandleUserSelectionOpts) (userId *string, err error) {
	var logs chan<- common.ServiceLog
	if opts.ServiceLog == nil {
		initNoopServiceLog()
		logs = noopServiceLog
		go startNoopServiceLog()
		defer stopNoopServiceLog()
	} else {
		logs = opts.ServiceLog
	}
	logs <- common.ServiceLogf(common.LogLevelDebug, "processing input list of users")
	isUserInputValid := true
	isUserInputUuid := true
	if _, err := uuid.Parse(opts.UserInput); err != nil {
		isUserInputUuid = false
		if err := validate.Email(opts.UserInput); err != nil {
			isUserInputValid = false
		}
	}
	choices := []SelectorChoice{}
	for _, user := range opts.Users {
		if isUserInputValid {
			selector := user.Id
			if !isUserInputUuid {
				selector = user.Email
			}
			if selector == opts.UserInput {
				return &user.Id, nil
			}
		}
		choices = append(choices, SelectorChoice{
			Description: user.Id,
			Label:       user.Email,
			Value:       user.Id,
		})
	}
	fmt.Println("ðŸ’¬ Which user will it be?")
	fmt.Println("")
	sort.Slice(choices, func(i, j int) bool {
		return choices[i].Label < choices[j].Label
	})
	userSelection := CreateSelector(SelectorOpts{
		Choices: choices,
	})
	userSelector := tea.NewProgram(userSelection)
	if _, err := userSelector.Run(); err != nil {
		logs <- common.ServiceLogf(common.LogLevelError, "failed to get user input: %s", err)
		return nil, fmt.Errorf("failed to get user input: %w", err)
	}
	if userSelection.GetExitCode() == PromptCancelled {
		return nil, errors.New("user cancelled")
	}
	selectedUser := userSelection.GetValue()

	return &selectedUser, nil
}
