package cli

import (
	"errors"
	"fmt"
	"opsicle/internal/common"
	"opsicle/internal/validate"
	"opsicle/pkg/controller"
	"sort"

	tea "github.com/charmbracelet/bubbletea"
	"github.com/google/uuid"
)

type SelectedUser struct {
	Id    string
	Email string
}

type handleUserSelectionOpts struct {
	// Client should be generated by the cosnuming function
	// and passed into this function for us
	Client *controller.Client

	// UserInput is what a user has input as the org code
	UserInput string

	// Users is a list of selectable users
	Users []handleUserSelectionOptsUser

	// ServiceLog is used for streaming logs
	ServiceLog chan<- common.ServiceLog
}

type handleUserSelectionOptsUser struct {
	Id    string
	Email string
}

// handleUserSelection handles the selection of an organsation
// in the CLI; this is not exposed because there can be many
// types of users (eg. org user, template user etc) so this is a
// utility function that connects them all. All convenience
// functions that involve a user selection should call this for
// the selection UX
func handleUserSelection(opts handleUserSelectionOpts) (user *SelectedUser, err error) {
	var logs chan<- common.ServiceLog
	if opts.ServiceLog == nil {
		initNoopServiceLog()
		logs = noopServiceLog
		go startNoopServiceLog()
		defer stopNoopServiceLog()
	} else {
		logs = opts.ServiceLog
	}
	logs <- common.ServiceLogf(common.LogLevelDebug, "processing input list of users")
	isUserInputValid := true
	isUserInputUuid := true
	if _, err := uuid.Parse(opts.UserInput); err != nil {
		isUserInputUuid = false
		if err := validate.Email(opts.UserInput); err != nil {
			isUserInputValid = false
		}
	}
	userIdToEmailMap := map[string]string{}
	choices := []SelectorChoice{}
	for _, user := range opts.Users {
		userIdToEmailMap[user.Id] = user.Email
		if isUserInputValid {
			selector := user.Id
			if !isUserInputUuid {
				selector = user.Email
			}
			if selector == opts.UserInput {
				return &SelectedUser{
					Id:    user.Id,
					Email: user.Email,
				}, nil
			}
		}
		choices = append(choices, SelectorChoice{
			Description: user.Id,
			Label:       user.Email,
			Value:       user.Id,
		})
	}
	fmt.Println("ðŸ’¬ Which user will it be?")
	fmt.Println("")
	sort.Slice(choices, func(i, j int) bool {
		return choices[i].Label < choices[j].Label
	})
	userSelection := CreateSelector(SelectorOpts{
		Choices: choices,
	})
	userSelector := tea.NewProgram(userSelection)
	if _, err := userSelector.Run(); err != nil {
		logs <- common.ServiceLogf(common.LogLevelError, "failed to get user input: %s", err)
		return nil, fmt.Errorf("failed to get user input: %w", err)
	}
	if userSelection.GetExitCode() == PromptCancelled {
		return nil, errors.New("user cancelled")
	}
	selectedUserId := userSelection.GetValue()
	selectedUserEmail := userIdToEmailMap[selectedUserId]

	return &SelectedUser{
		Id:    selectedUserId,
		Email: selectedUserEmail,
	}, nil
}
