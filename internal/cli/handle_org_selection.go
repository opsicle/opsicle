package cli

import (
	"errors"
	"fmt"
	"opsicle/internal/common"
	"opsicle/pkg/controller"
	"sort"

	tea "github.com/charmbracelet/bubbletea"
)

type SelectedOrg struct {
	Code string
	Id   string
}

type HandleOrgSelectionOpts struct {
	// Client should be generated by the cosnuming function
	// and passed into this function for us
	Client *controller.Client

	// UserInput is what a user has input as the org code
	UserInput string

	// ServiceLog is used for streaming logs
	ServiceLog chan<- common.ServiceLog
}

// HandleOrgSelection handles the selection of an organsation
// in the CLI
func HandleOrgSelection(opts HandleOrgSelectionOpts) (orgCode *SelectedOrg, err error) {
	var logs chan<- common.ServiceLog
	if opts.ServiceLog == nil {
		initNoopServiceLog()
		logs = noopServiceLog
		go startNoopServiceLog()
		defer stopNoopServiceLog()
	} else {
		logs = opts.ServiceLog
	}
	logs <- common.ServiceLogf(common.LogLevelDebug, "retrieving available organisations to current user")
	var output *SelectedOrg
	listOrgsOutput, err := opts.Client.ListOrgsV1()
	if err != nil || listOrgsOutput == nil {
		logs <- common.ServiceLogf(common.LogLevelError, "listing orgs failed: %s", err)
		return nil, fmt.Errorf("controller request failed: %w", err)
	}
	isUserInputValid := false
	for _, listedOrg := range listOrgsOutput.Data {
		if listedOrg.Code == opts.UserInput {
			isUserInputValid = true
			output = &SelectedOrg{
				Code: listedOrg.Code,
				Id:   listedOrg.Id,
			}
			break
		}
	}
	if isUserInputValid {
		return output, nil
	}
	if opts.UserInput != "" {
		fmt.Printf("⚠️  The organisation <%s> does not seem valid\n", opts.UserInput)
	}

	fmt.Println(styleBold.Render("💬 Which organisation will it be?"))
	fmt.Println("")
	choices := []SelectorChoice{}
	orgCodeIdMap := map[string]string{}
	for _, org := range listOrgsOutput.Data {
		orgCodeIdMap[org.Code] = org.Id
		choices = append(choices, SelectorChoice{
			Description: org.Name,
			Label:       org.Code,
			Value:       org.Code,
		})
	}
	sort.Slice(choices, func(i, j int) bool {
		return choices[i].Label < choices[j].Label
	})
	orgSelection := CreateSelector(SelectorOpts{
		Choices: choices,
	})
	orgSelector := tea.NewProgram(orgSelection)
	if _, err := orgSelector.Run(); err != nil {
		logs <- common.ServiceLogf(common.LogLevelError, "failed to get user input: %s", err)
		return nil, fmt.Errorf("failed to get user input: %w", err)
	}
	if orgSelection.GetExitCode() == PromptCancelled {
		return nil, errors.New("user cancelled")
	}
	selectedOrgCode := orgSelection.GetValue()
	selectedOrgId, ok := orgCodeIdMap[selectedOrgCode]
	if !ok {
		return nil, fmt.Errorf("failed to get org id from code[%s]", selectedOrgCode)
	}

	return &SelectedOrg{
		Code: selectedOrgCode,
		Id:   selectedOrgId,
	}, nil
}
