package cli

import (
	"strings"
	"unicode/utf8"
)

// countLines returns the number of lines in s.
// A trailing newline adds an empty last line.
func countLines(s string) int {
	if s == "" {
		return 0
	}
	return strings.Count(s, "\n") + 1
}

// wrapString wraps s to lines of at most width runes.
// It breaks on spaces where possible, and hard-wraps long words.
// Generated by ChatGPT
func wrapString(s string, width int) string {
	if width <= 0 {
		return s
	}

	var out []string
	var line strings.Builder
	lineLen := 0

	for _, word := range strings.Fields(s) {
		wlen := utf8.RuneCountInString(word)

		// if word itself is longer than width, break it
		if wlen > width {
			// flush current line if not empty
			if lineLen > 0 {
				out = append(out, line.String())
				line.Reset()
				lineLen = 0
			}
			// hard split the word
			runes := []rune(word)
			for i := 0; i < len(runes); i += width {
				end := i + width
				if end > len(runes) {
					end = len(runes)
				}
				out = append(out, string(runes[i:end]))
			}
			continue
		}

		// if word fits on current line, add it
		if lineLen == 0 {
			line.WriteString(word)
			lineLen = wlen
		} else if lineLen+1+wlen <= width {
			line.WriteByte(' ')
			line.WriteString(word)
			lineLen += 1 + wlen
		} else {
			// wrap: push current line and start new one
			out = append(out, line.String())
			line.Reset()
			line.WriteString(word)
			lineLen = wlen
		}
	}

	// flush remainder
	if lineLen > 0 {
		out = append(out, line.String())
	}

	return strings.Join(out, "\n")
}
